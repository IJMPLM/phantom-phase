import { world, system, Player } from "@minecraft/server";

// Set to track players that should be invulnerable
const invulnerablePlayers = new Set<string>();

// Map of damage type strings for handling different damage types
const DAMAGE_TYPES = {
  FIRE: 'fire',
  FIRE_TICK: 'fireTick',
  LAVA: 'lava',
  DROWNING: 'drowning',
};

// Debug configuration for invulnerability system
let debugMessages = true;

/**
 * Make a player completely invulnerable to all damage types
 * @param player The player to make invulnerable
 */
export function makePlayerInvulnerable(player: Player): void {
  try {
    // Add to invulnerable players set
    invulnerablePlayers.add(player.id);
    
    // Use vanilla ability command for additional protection
    // This helps with fire ticks, drowning, etc.
    player.runCommand("ability @s mayfly true");
    player.runCommand("ability @s invulnerable true");
    
    // Extinguish fire if player is on fire
    player.runCommand("effect @s fire_resistance 1 1 true");
    
    // For debugging only
    if (debugMessages) {
      console.warn(`[PhaseInvulnerability] Player ${player.name} is now invulnerable`);
    }
  } catch (e) {
    if (debugMessages) {
      world.sendMessage(`§cFailed to make ${player.name} invulnerable: ${e}`);
    }
  }
}

/**
 * Remove invulnerability from a player
 * @param player The player to make vulnerable again
 */
export function removePlayerInvulnerability(player: Player): void {
  try {
    // Remove from invulnerable players set
    invulnerablePlayers.delete(player.id);
    
    // Remove abilities
    player.runCommand("ability @s mayfly false");
    player.runCommand("ability @s invulnerable false");
    
    // For debugging only
    if (debugMessages) {
      console.warn(`[PhaseInvulnerability] Player ${player.name} is no longer invulnerable`);
    }
  } catch (e) {
    if (debugMessages) {
      world.sendMessage(`§cFailed to remove invulnerability from ${player.name}: ${e}`);
    }
  }
}

/**
 * Check if a player is currently invulnerable
 * @param player The player to check
 * @returns True if player is invulnerable
 */
export function isPlayerInvulnerable(playerId: string): boolean {
  return invulnerablePlayers.has(playerId);
}

/**
 * Set the debug mode for the invulnerability system
 * @param enabled Whether to enable debug messages
 */
export function setInvulnerabilityDebug(enabled: boolean): void {
  debugMessages = enabled;
}

/**
 * Clear all invulnerability tracking data (used when reloading scripts)
 */
export function clearInvulnerabilityData(): void {
  invulnerablePlayers.clear();
}

// Initialize damage event handler
function initializeDamageHandler(): void {
  // For Minecraft Bedrock 1.20.70+, we'll need to handle damage prevention
  // without directly hooking into afterEvents.entityDamage
  
  // Instead, we'll use a tick handler to continuously check and protect invulnerable players
  system.runInterval(() => {
    for (const playerId of invulnerablePlayers) {
      try {
        const player = world.getAllPlayers().find(p => p.id === playerId);
        if (!player) continue;
        
        // Apply invulnerability
        player.runCommand("ability @s invulnerable true");
        
        // Apply fire resistance to handle fire damage
        if (player.hasTag("on_fire") || player.dimension.getBlock(player.location)?.typeId?.includes("lava")) {
          player.runCommand("effect @s fire_resistance 2 1 true");
          player.runCommand("execute as @s run tag @s remove on_fire");
        }
        
        // Apply water breathing to prevent drowning
        if (player.dimension.getBlock(player.location)?.typeId?.includes("water")) {
          player.runCommand("effect @s water_breathing 2 1 true");
        }
      } catch (e) {
        if (debugMessages) {
          console.error(`[PhaseInvulnerability] Error in protection handler: ${e}`);
        }
      }
    }
  }, 5); // Check every 5 ticks
  
  // Register tick handler to keep applying effects
  const tickIntervalId = system.runInterval(() => {
    for (const playerId of invulnerablePlayers) {
      try {
        const player = world.getAllPlayers().find(p => p.id === playerId);
        if (player) {
          // Re-apply invulnerability every 5 seconds in case it was reset
          if (system.currentTick % 100 === 0) {
            player.runCommand("ability @s invulnerable true");
          }
          
          // Check if player is in void and teleport them up if needed
          if (player.location.y < -60) {
            player.teleport({
              x: player.location.x,
              y: 0,
              z: player.location.z
            }, {dimension: player.dimension});
            
            if (debugMessages) {
              console.warn(`[PhaseInvulnerability] Saved ${player.name} from void death`);
            }
          }
        }
      } catch (e) {
        if (debugMessages) {
          console.error(`[PhaseInvulnerability] Error in tick handler for player: ${e}`);
        }
      }
    }
  }, 20); // Run every second
  
  // Clean up on reload
  system.afterEvents.scriptEventReceive.subscribe((event) => {
    if (event.id === "phantom:cleanup_invulnerability") {
      system.clearRun(tickIntervalId);
      clearInvulnerabilityData();
    }
  });
}

// Initialize the module
initializeDamageHandler();