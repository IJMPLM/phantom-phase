import { world, system } from "@minecraft/server";
// Set to track players that should be invulnerable
const invulnerablePlayers = new Set();
// Map of damage type strings for handling different damage types
const DAMAGE_TYPES = {
    FIRE: "fire",
    FIRE_TICK: "fireTick",
    LAVA: "lava",
    DROWNING: "drowning",
};
// Debug configuration for invulnerability system
let debugMessages = true;
/**
 * Make a player completely invulnerable to all damage types
 * @param player The player to make invulnerable
 */
export function makePlayerInvulnerable(player) {
    try {
        // Add to invulnerable players set
        invulnerablePlayers.add(player.id);
        // Use vanilla ability command for additional protection
        // This helps with fire ticks, drowning, etc.
        player.runCommand("ability @s mayfly true");
        player.runCommand("ability @s invulnerable true");
        // Extinguish fire if player is on fire
        player.runCommand("effect @s fire_resistance 1 1 true");
        // For debugging only
        if (debugMessages) {
            console.warn(`[PhaseInvulnerability] Player ${player.name} is now invulnerable`);
        }
    }
    catch (e) {
        if (debugMessages) {
            world.sendMessage(`§cFailed to make ${player.name} invulnerable: ${e}`);
        }
    }
}
/**
 * Remove invulnerability from a player
 * @param player The player to make vulnerable again
 */
export function removePlayerInvulnerability(player) {
    try {
        // Remove from invulnerable players set
        invulnerablePlayers.delete(player.id);
        // Remove abilities
        player.runCommand("ability @s mayfly false");
        player.runCommand("ability @s invulnerable false");
        // For debugging only
        if (debugMessages) {
            console.warn(`[PhaseInvulnerability] Player ${player.name} is no longer invulnerable`);
        }
    }
    catch (e) {
        if (debugMessages) {
            world.sendMessage(`§cFailed to remove invulnerability from ${player.name}: ${e}`);
        }
    }
}
/**
 * Check if a player is currently invulnerable
 * @param player The player to check
 * @returns True if player is invulnerable
 */
export function isPlayerInvulnerable(playerId) {
    return invulnerablePlayers.has(playerId);
}
/**
 * Set the debug mode for the invulnerability system
 * @param enabled Whether to enable debug messages
 */
export function setInvulnerabilityDebug(enabled) {
    debugMessages = enabled;
}
/**
 * Clear all invulnerability tracking data (used when reloading scripts)
 */
export function clearInvulnerabilityData() {
    invulnerablePlayers.clear();
}
// Initialize damage event handler
function initializeDamageHandler() {
    // For Minecraft Bedrock 1.20.70+, we'll need to handle damage prevention
    // without directly hooking into afterEvents.entityDamage
    // Instead, we'll use a tick handler to continuously check and protect invulnerable players
    system.runInterval(() => {
        var _a, _b, _c, _d;
        for (const playerId of invulnerablePlayers) {
            try {
                const player = world.getAllPlayers().find((p) => p.id === playerId);
                if (!player)
                    continue;
                // Apply invulnerability
                player.runCommand("ability @s invulnerable true");
                // Apply fire resistance to handle fire damage
                if (player.hasTag("on_fire") || ((_b = (_a = player.dimension.getBlock(player.location)) === null || _a === void 0 ? void 0 : _a.typeId) === null || _b === void 0 ? void 0 : _b.includes("lava"))) {
                    player.runCommand("effect @s fire_resistance 2 1 true");
                    player.runCommand("execute as @s run tag @s remove on_fire");
                }
                // Apply water breathing to prevent drowning
                if ((_d = (_c = player.dimension.getBlock(player.location)) === null || _c === void 0 ? void 0 : _c.typeId) === null || _d === void 0 ? void 0 : _d.includes("water")) {
                    player.runCommand("effect @s water_breathing 2 1 true");
                }
            }
            catch (e) {
                if (debugMessages) {
                    console.error(`[PhaseInvulnerability] Error in protection handler: ${e}`);
                }
            }
        }
    }, 5); // Check every 5 ticks
    // Register tick handler to keep applying effects
    const tickIntervalId = system.runInterval(() => {
        for (const playerId of invulnerablePlayers) {
            try {
                const player = world.getAllPlayers().find((p) => p.id === playerId);
                if (player) {
                    // Re-apply invulnerability every 5 seconds in case it was reset
                    if (system.currentTick % 100 === 0) {
                        player.runCommand("ability @s invulnerable true");
                    }
                    // Check if player is in void and teleport them up if needed
                    if (player.location.y < -60) {
                        player.teleport({
                            x: player.location.x,
                            y: 0,
                            z: player.location.z,
                        }, { dimension: player.dimension });
                        if (debugMessages) {
                            console.warn(`[PhaseInvulnerability] Saved ${player.name} from void death`);
                        }
                    }
                }
            }
            catch (e) {
                if (debugMessages) {
                    console.error(`[PhaseInvulnerability] Error in tick handler for player: ${e}`);
                }
            }
        }
    }, 20); // Run every second
    // Clean up on reload
    system.afterEvents.scriptEventReceive.subscribe((event) => {
        if (event.id === "phantom:cleanup_invulnerability") {
            system.clearRun(tickIntervalId);
            clearInvulnerabilityData();
        }
    });
}
// Initialize the module
initializeDamageHandler();
//# sourceMappingURL=phase-mode-invulnerability.js.map