{"version":3,"sources":["../../scripts/main.ts","../../scripts/phase-mode.ts","../../scripts/phase-mode-speedometer.ts"],"sourcesContent":["import { world, system } from \"@minecraft/server\";\nimport { initializePhantomPhase, updatePhaseConfig } from \"./phase-mode\";\n\nlet ticksSinceLoad = 0;\n\nfunction mainTick() {\n  ticksSinceLoad++;\n\n  if (ticksSinceLoad === 60) {\n    world.sendMessage(\"§6Phantom Phase system with speedometer2...\");\n    initialize();\n  }\n\n  system.run(mainTick);\n}\n\nfunction initialize() {\n  // Initialize the phantom phase system with custom configuration\n  initializePhantomPhase({\n    speedThresholdBps: 25.0, // Enter phase mode at this speed (blocks/second)\n    exitSpeedThresholdBps: 7.0, // Exit phase mode below this speed\n    inactiveFramesThreshold: 20, // Wait this many frames below exit speed before leaving phase mode\n    debugMessages: true, // Show debug messages\n    preserveInventory: true, // Don't lose inventory during mode changes\n    phaseBlockCheckDistance: 10, // Check for blocks this many blocks ahead\n    alwaysUseSpectator: false, // Only use spectator when blocks are ahead\n  });\n\n  // Example of updating configuration later if needed\n  // system.runTimeout(() => {\n  //   updatePhaseConfig({\n  //     speedThresholdBps: 2.5,  // Lower threshold for easier activation\n  //     debugMessages: false     // Turn off debug messages after initial setup\n  //   });\n  // }, 1200); // 1 minute later (20 ticks/second * 60 seconds)\n}\n\nsystem.run(mainTick);\n","import { world, system, Entity, GameMode, Player, Vector3 } from \"@minecraft/server\";\r\nimport { enableSpeedometer, disableSpeedometer } from \"./phase-mode-speedometer\";\r\n\r\n// Configuration interface for phantom phase system\r\ninterface PhaseConfig {\r\n  speedThresholdBps: number; // Speed threshold to enter phase mode (blocks per second)\r\n  exitSpeedThresholdBps: number; // Speed threshold to exit phase mode (blocks per second)\r\n  inactiveFramesThreshold: number; // Number of frames below exit speed before exiting phase mode\r\n  ticksPerSecond: number; // Game ticks per second (for calculations)\r\n  speedCheckInterval: number; // How often to check player speeds (in ticks)\r\n  debugUpdateInterval: number; // How often to show debug messages (in ticks)\r\n  debugMessages: boolean; // Whether to show debug messages\r\n  preserveInventory: boolean; // Whether to preserve inventory during mode changes\r\n  gameModeSwitchDelay: number; // Delay in ticks for game mode switches (improves reliability)\r\n  strictValidation: boolean; // Whether to use strict player validation\r\n  phaseBlockCheckDistance: number; // Distance to check for blocks ahead before entering spectator mode\r\n  alwaysUseSpectator: boolean; // Whether to always use spectator mode regardless of blocks ahead\r\n}\r\n\r\n// Player phase mode data type\r\ninterface PhasePlayerData {\r\n  player: Player;\r\n  lastPosition: Vector3;\r\n  previousSpeed: number;\r\n  inactiveFrames: number;\r\n  previousGameMode?: GameMode;\r\n}\r\n\r\n// Map to track players in phase mode\r\nconst playersInPhaseMode = new Map<string, PhasePlayerData>();\r\n\r\n// Default configuration constants\r\nconst DEFAULT_CONFIG: PhaseConfig = {\r\n  speedThresholdBps: 25.0,\r\n  exitSpeedThresholdBps: 7.0,\r\n  inactiveFramesThreshold: 20,\r\n  ticksPerSecond: 60,\r\n  speedCheckInterval: 1,\r\n  debugUpdateInterval: 10,\r\n  gameModeSwitchDelay: 1,\r\n  strictValidation: true,\r\n  debugMessages: true,\r\n  preserveInventory: true,\r\n  phaseBlockCheckDistance: 10, // Check 10 blocks ahead by default\r\n  alwaysUseSpectator: false, // Only use spectator when blocks are ahead\r\n};\r\n\r\n// Active configuration\r\nlet config: PhaseConfig = { ...DEFAULT_CONFIG };\r\n\r\n// Store the update interval ID so we can clear it if needed\r\nlet updateIntervalId: number | undefined;\r\n\r\n/**\r\n * Gets player speed directly from the flying_speed component\r\n * Throws an error if the component is not available\r\n */\r\nfunction calculatePlayerSpeed(\r\n  player: Player,\r\n  previousPosition: Vector3,\r\n  intervalTicks: number = config.speedCheckInterval\r\n): number {\r\n  const velocity = player.getVelocity();\r\n  return 17 * Math.sqrt(velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2);\r\n}\r\n\r\n/**\r\n * Switches player to spectator mode (or invulnerable mode) and adds them to phase mode tracking\r\n * If there's a block ahead or alwaysUseSpectator is true: enters spectator mode\r\n * Otherwise: keeps current game mode but makes player invulnerable\r\n */\r\nfunction enterPhaseMode(player: Player): void {\r\n  // Prevent redundant mode changes if already in spectator\r\n  if (player.getGameMode() === GameMode.spectator) {\r\n    if (config.debugMessages) {\r\n      world.sendMessage(`§e${player.name} is already in spectator mode, not entering phase mode again.`);\r\n    }\r\n    return;\r\n  }\r\n\r\n  try {\r\n    // Store the previous game mode before changing it\r\n    const previousMode = player.getGameMode();\r\n\r\n    // Add player to phase mode tracking before mode change to prevent race conditions\r\n    playersInPhaseMode.set(player.id, {\r\n      player,\r\n      lastPosition: player.location,\r\n      previousSpeed: 0,\r\n      inactiveFrames: 0,\r\n      previousGameMode: previousMode,\r\n    });\r\n\r\n    // Check if there's a block ahead or if we should always use spectator\r\n    const shouldUseSpectator = config.alwaysUseSpectator || isBlockAheadOfPlayer(player);\r\n\r\n    // Queue the game mode change to happen after a delay for better reliability\r\n    system.runTimeout(() => {\r\n      try {\r\n        // Verify player is still valid and eligible for mode change\r\n        if (player && player.id && !player.isValid?.()) {\r\n          world.sendMessage(`§cPlayer ${player.name} is no longer valid, aborting phase mode entry`);\r\n          playersInPhaseMode.delete(player.id);\r\n          return;\r\n        }\r\n\r\n        if (shouldUseSpectator) {\r\n          // Double check that player hasn't already changed modes\r\n          if (player.getGameMode() !== GameMode.spectator) {\r\n            // Explicitly force spectator mode\r\n            player.setGameMode(GameMode.spectator);\r\n            world.sendMessage(`§b${player.name} is phasing out of reality! (from ${previousMode} mode)`);\r\n          }\r\n        } else {\r\n          // Make player invulnerable but keep their current game mode\r\n          // Apply abilities for invulnerability\r\n          try {\r\n            player.runCommand(\"ability @s mayfly true\");\r\n            player.runCommand(\"ability @s invulnerable true\");\r\n            world.sendMessage(`§d${player.name} is phasing (staying in ${previousMode} mode with invulnerability)`);\r\n          } catch (abilityError) {\r\n            world.sendMessage(`§cERROR: Failed to apply abilities: ${abilityError}`);\r\n          }\r\n        }\r\n      } catch (err) {\r\n        world.sendMessage(`§cERROR: Failed to set phase mode: ${err}`);\r\n        // Clean up tracking data on failure\r\n        playersInPhaseMode.delete(player.id);\r\n      }\r\n    }, config.gameModeSwitchDelay); // Configurable delay for stability\r\n  } catch (e) {\r\n    world.sendMessage(`§cERROR: Failed to set ${player.name} to phase mode: ${e}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Switches player back to their previous mode and removes them from phase tracking\r\n * Removes invulnerability if it was applied\r\n */\r\nfunction exitPhaseMode(player: Player): void {\r\n  try {\r\n    // Get phase data and validate it exists\r\n    const phaseData = playersInPhaseMode.get(player.id);\r\n    if (!phaseData) {\r\n      world.sendMessage(`§cWARNING: No phase data found for ${player.name} when trying to exit phase mode`);\r\n      return;\r\n    }\r\n\r\n    // Use the previous game mode if available, otherwise default to survival\r\n    const targetMode = phaseData.previousGameMode ?? GameMode.survival;\r\n\r\n    // Store a local copy of needed data before removing tracking\r\n    const playerName = player.name;\r\n    const playerId = player.id;\r\n\r\n    // Remove from tracking first to prevent re-entry race conditions\r\n    playersInPhaseMode.delete(playerId);\r\n\r\n    // Schedule the game mode change with a slight delay for better reliability\r\n    system.runTimeout(() => {\r\n      try {\r\n        // Verify player is still valid before proceeding\r\n        if (!player || !player.id || !player.isValid?.()) {\r\n          world.sendMessage(`§cPlayer ${playerName} is no longer valid, aborting phase mode exit`);\r\n          return;\r\n        }\r\n\r\n        // Check current game mode and switch if appropriate\r\n        const currentMode = player.getGameMode();\r\n\r\n        // Remove any abilities granted (invulnerability, etc.)\r\n        try {\r\n          player.runCommand(\"ability @s mayfly false\");\r\n          player.runCommand(\"ability @s invulnerable false\");\r\n        } catch (e) {\r\n          // Ignore ability errors, they're not critical\r\n        }\r\n\r\n        if (currentMode === GameMode.spectator) {\r\n          // Explicitly force target mode\r\n          player.setGameMode(targetMode);\r\n\r\n          // Update speedometer to show new state but don't disable it\r\n          enableSpeedometer(player, config.speedThresholdBps, config.exitSpeedThresholdBps, true);\r\n\r\n          world.sendMessage(`§a${playerName} has returned to reality! (back to ${targetMode} mode)`);\r\n        } else if (currentMode !== targetMode) {\r\n          // They're in an unexpected mode, switch to target mode\r\n          world.sendMessage(`§e${playerName} is in ${currentMode} mode, restoring to ${targetMode} mode`);\r\n          player.setGameMode(targetMode);\r\n\r\n          // Update speedometer to show new state\r\n          enableSpeedometer(player, config.speedThresholdBps, config.exitSpeedThresholdBps, true);\r\n        } else {\r\n          // They're already in the target mode, just remove abilities\r\n          world.sendMessage(`§e${playerName} is no longer phasing (invulnerability removed)`);\r\n\r\n          // Update speedometer to show new state\r\n          enableSpeedometer(player, config.speedThresholdBps, config.exitSpeedThresholdBps, true);\r\n        }\r\n      } catch (err) {\r\n        world.sendMessage(`§cERROR: Failed to restore game mode for ${playerName}: ${err}`);\r\n      }\r\n    }, config.gameModeSwitchDelay); // Configurable delay for stability\r\n  } catch (e) {\r\n    world.sendMessage(`§cERROR: Failed to restore ${player.name}'s game mode: ${e}`);\r\n    // Still try to clean up the tracking data\r\n    playersInPhaseMode.delete(player.id);\r\n  }\r\n}\r\n\r\n/**\r\n * Displays debug information about a player's current speed and phase status\r\n */\r\nfunction logPlayerDebugInfo(player: Player): void {\r\n  if (!config.debugMessages || system.currentTick % config.debugUpdateInterval !== 0) {\r\n    return;\r\n  }\r\n\r\n  const currentPos = player.location;\r\n  const playerData = playersInPhaseMode.get(player.id);\r\n  const isInPhaseMode = playerData && player.getGameMode() === GameMode.spectator;\r\n  const lastPos = playerData ? playerData.lastPosition : currentPos;\r\n\r\n  try {\r\n    const speed = calculatePlayerSpeed(player, lastPos);\r\n    const speedColor = speed > config.speedThresholdBps ? \"§a\" : speed > config.exitSpeedThresholdBps ? \"§e\" : \"§c\";\r\n\r\n    world.sendMessage(\r\n      `§7${player.name}: speed=${speedColor}${speed.toFixed(2)} §7b/s, isGliding=${\r\n        player.isGliding ? \"§aYes\" : \"§cNo\"\r\n      }, gameMode=${player.getGameMode()}, phaseMode=${isInPhaseMode ? \"§aYES\" : \"§cNO\"}`\r\n    );\r\n  } catch (e: any) {\r\n    // If we can't get speed, just show that the component is not available\r\n    world.sendMessage(\r\n      `§7${player.name}: §cSpeed component not available, isGliding=${\r\n        player.isGliding ? \"§aYes\" : \"§cNo\"\r\n      }, gameMode=${player.getGameMode()}, phaseMode=${isInPhaseMode ? \"§aYES\" : \"§cNO\"}`\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Initializes tracking data for a new player\r\n */\r\nfunction initializePlayerTracking(player: Player): PhasePlayerData {\r\n  return {\r\n    player,\r\n    lastPosition: player.location,\r\n    previousSpeed: 0,\r\n    inactiveFrames: 0,\r\n    previousGameMode: player.getGameMode(),\r\n  };\r\n}\r\n\r\n/**\r\n * Updates phase status for players already in phase mode\r\n */\r\nfunction updateExistingPhasePlayer(player: Player, phaseData: PhasePlayerData): void {\r\n  try {\r\n    const currentSpeed = calculatePlayerSpeed(player, phaseData.lastPosition);\r\n\r\n    phaseData.lastPosition = player.location;\r\n    phaseData.previousSpeed = currentSpeed;\r\n\r\n    if (currentSpeed < config.exitSpeedThresholdBps) {\r\n      phaseData.inactiveFrames++;\r\n\r\n      if (phaseData.inactiveFrames >= config.inactiveFramesThreshold) {\r\n        exitPhaseMode(player);\r\n      }\r\n    } else {\r\n      phaseData.inactiveFrames = 0;\r\n    }\r\n  } catch (e: any) {\r\n    if (config.debugMessages) {\r\n      world.sendMessage(`§c${player.name}: ${e.message}`);\r\n    }\r\n    // If we can't get speed, just keep current state\r\n  }\r\n}\r\n\r\n/**\r\n * Updates and checks players not in phase mode\r\n */\r\nfunction updateRegularPlayer(player: Player): void {\r\n  try {\r\n    let playerData = playersInPhaseMode.get(player.id) || initializePlayerTracking(player);\r\n\r\n    const currentSpeed = calculatePlayerSpeed(player, playerData.lastPosition);\r\n    playerData.lastPosition = player.location;\r\n    playerData.previousSpeed = currentSpeed;\r\n\r\n    if (currentSpeed > config.speedThresholdBps) {\r\n      if (config.debugMessages) {\r\n        world.sendMessage(`§e${player.name} triggered phase mode at ${currentSpeed.toFixed(1)} b/s`);\r\n      }\r\n      enterPhaseMode(player);\r\n    } else if (!playersInPhaseMode.has(player.id)) {\r\n      playersInPhaseMode.set(player.id, playerData);\r\n    }\r\n  } catch (e: any) {\r\n    if (config.debugMessages) {\r\n      world.sendMessage(`§c${player.name}: ${e.message}`);\r\n    }\r\n    // If we can't get speed, don't update player state\r\n  }\r\n}\r\n\r\n/**\r\n * Updates a single player's phase state\r\n */\r\nfunction updatePlayerPhaseState(player: Player): void {\r\n  try {\r\n    // Avoid processing creative/spectator players that aren't already tracked\r\n    const currentGameMode = player.getGameMode();\r\n    const isTracked = playersInPhaseMode.has(player.id);\r\n\r\n    // Don't start tracking spectator players who aren't already tracked\r\n    if (!isTracked && currentGameMode === GameMode.spectator && !isPhaseModeCaused(player)) {\r\n      return;\r\n    }\r\n\r\n    // Get phase data if it exists\r\n    const phaseData = playersInPhaseMode.get(player.id);\r\n\r\n    // If player is in spectator mode and we're tracking them, they're in phase mode\r\n    if (phaseData && currentGameMode === GameMode.spectator) {\r\n      updateExistingPhasePlayer(player, phaseData);\r\n    } else {\r\n      // Otherwise update as a regular player\r\n      updateRegularPlayer(player);\r\n    }\r\n  } catch (e) {\r\n    // Handle any errors that might occur during player state update\r\n    if (config.debugMessages) {\r\n      world.sendMessage(`§cError updating player phase state: ${e}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if the player is in phase mode (spectator or invulnerable)\r\n * rather than manually switching to spectator\r\n */\r\nfunction isPhaseModeCaused(player: Player): boolean {\r\n  // If the player is being tracked, they're in phase mode\r\n  const phaseData = playersInPhaseMode.get(player.id);\r\n  return !!phaseData;\r\n}\r\n\r\n/**\r\n * Checks if there's a solid block within the specified distance in front of the player\r\n * @param player The player to check\r\n * @param maxDistance Maximum distance to check for blocks (default: 10)\r\n * @returns True if a solid block is found within the distance\r\n */\r\nfunction isBlockAheadOfPlayer(player: Player, maxDistance: number = config.phaseBlockCheckDistance): boolean {\r\n  try {\r\n    // Get the block the player is looking at with specified max distance\r\n    const blockRaycastHit = player.getBlockFromViewDirection({ maxDistance });\r\n\r\n    // If we found a block and it's solid, return true\r\n    if (blockRaycastHit && blockRaycastHit.block) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  } catch (e) {\r\n    if (config.debugMessages) {\r\n      world.sendMessage(`§cError checking blocks ahead: ${e}`);\r\n    }\r\n    // Default to true on error (safer)\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Updates all players' phase status based on speed and conditions\r\n */\r\nfunction updatePlayersInPhaseMode(): void {\r\n  // Clean up players who have left the game first to avoid errors\r\n  cleanupDisconnectedPlayers();\r\n\r\n  const players = world.getAllPlayers();\r\n\r\n  for (const player of players) {\r\n    // Verify player is valid before processing\r\n    try {\r\n      if (player && player.id) {\r\n        logPlayerDebugInfo(player);\r\n        updatePlayerPhaseState(player);\r\n      }\r\n    } catch (err) {\r\n      if (config.debugMessages) {\r\n        world.sendMessage(`§cError updating player: ${err}`);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Clean up any disconnected players from tracking\r\n */\r\nfunction cleanupDisconnectedPlayers(): void {\r\n  // Get the current set of online players for quick lookup\r\n  const onlinePlayers = new Set(world.getAllPlayers().map((p) => p.id));\r\n\r\n  for (const [playerId, data] of playersInPhaseMode.entries()) {\r\n    try {\r\n      let shouldRemove = false;\r\n      let reason = \"unknown\";\r\n\r\n      // Check if player reference is valid\r\n      if (!data.player || !data.player.id) {\r\n        shouldRemove = true;\r\n        reason = \"invalid reference\";\r\n      }\r\n      // Check if player is still connected using the Set for faster lookup\r\n      else if (!onlinePlayers.has(playerId)) {\r\n        shouldRemove = true;\r\n        reason = \"not connected\";\r\n      }\r\n      // Check if player reference is stale or invalid\r\n      else {\r\n        try {\r\n          // Try to access player properties - will throw if reference is invalid\r\n          const _ = data.player.location;\r\n\r\n          // Check isValid method if available\r\n          if (data.player.isValid?.() === false) {\r\n            shouldRemove = true;\r\n            reason = \"reference invalid\";\r\n          }\r\n        } catch (accessError) {\r\n          shouldRemove = true;\r\n          reason = \"reference error\";\r\n        }\r\n      }\r\n\r\n      // Remove player if any check failed\r\n      if (shouldRemove) {\r\n        if (config.debugMessages) {\r\n          const playerName = data.player?.name || \"Unknown\";\r\n          world.sendMessage(`§7Removing player from phase tracking (${reason}): ${playerName}`);\r\n        }\r\n        playersInPhaseMode.delete(playerId);\r\n      }\r\n    } catch (e) {\r\n      // Catch any unexpected errors and remove player from tracking to be safe\r\n      playersInPhaseMode.delete(playerId);\r\n      if (config.debugMessages) {\r\n        world.sendMessage(`§cError during player cleanup: ${e}`);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Updates speedometer displays for all players\r\n */\r\nfunction updateAllSpeedometers(): void {\r\n  for (const player of world.getAllPlayers()) {\r\n    try {\r\n      if (player && player.id && player.isValid?.()) {\r\n        enableSpeedometer(player, config.speedThresholdBps, config.exitSpeedThresholdBps, true);\r\n      }\r\n    } catch (e) {\r\n      if (config.debugMessages) {\r\n        world.sendMessage(`§cError updating speedometer for ${player.name}: ${e}`);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Update the phantom phase configuration\r\n */\r\nexport function updatePhaseConfig(newConfig: Partial<PhaseConfig>): void {\r\n  config = {\r\n    ...config,\r\n    ...newConfig,\r\n  };\r\n\r\n  // Update speedometers for all players when config changes\r\n  updateAllSpeedometers();\r\n  if (config.debugMessages) {\r\n    world.sendMessage(`§7Phase mode configuration updated:`);\r\n    world.sendMessage(`§7Speed threshold: §f${config.speedThresholdBps.toFixed(1)} §7blocks/second`);\r\n    world.sendMessage(`§7Exit threshold: §f${config.exitSpeedThresholdBps.toFixed(1)} §7blocks/second`);\r\n\r\n    // Only show the block check settings if they were changed\r\n    if (newConfig.phaseBlockCheckDistance !== undefined || newConfig.alwaysUseSpectator !== undefined) {\r\n      world.sendMessage(`§7Block check distance: §f${config.phaseBlockCheckDistance} §7blocks`);\r\n      world.sendMessage(\r\n        `§7Always use spectator: §f${config.alwaysUseSpectator ? \"Yes\" : \"No\"} §7(${\r\n          config.alwaysUseSpectator ? \"Always spectator\" : \"Spectator only for blocks\"\r\n        })`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Initializes the phantom phase system that switches fast-moving players to spectator mode\r\n */\r\nexport function initializePhantomPhase(customConfig?: Partial<PhaseConfig>) {\r\n  try {\r\n    // Apply any custom configuration\r\n    if (customConfig) {\r\n      updatePhaseConfig(customConfig);\r\n    }\r\n    world.sendMessage(\"§2Phantom Phase system activated!\");\r\n    world.sendMessage(`§7Phase speed threshold: §f${config.speedThresholdBps.toFixed(1)} §7blocks/second`);\r\n    world.sendMessage(`§7Exit speed threshold: §f${config.exitSpeedThresholdBps.toFixed(1)} §7blocks/second`);\r\n    world.sendMessage(`§7Mode change delay: §f${config.inactiveFramesThreshold} §7frames`);\r\n    world.sendMessage(`§7Block check distance: §f${config.phaseBlockCheckDistance} §7blocks`);\r\n    world.sendMessage(\r\n      `§7Always use spectator: §f${config.alwaysUseSpectator ? \"Yes\" : \"No\"} §7(${\r\n        config.alwaysUseSpectator ? \"Always spectator\" : \"Spectator only for blocks\"\r\n      })`\r\n    );\r\n    // Clear any existing players in phase mode\r\n    playersInPhaseMode.clear(); // Initialize tracking and enable speedometer for all current players\r\n    for (const player of world.getAllPlayers()) {\r\n      try {\r\n        // Enable speedometer for ALL players regardless of game mode\r\n        if (player && player.id && player.isValid?.() !== false) {\r\n          enableSpeedometer(player, config.speedThresholdBps, config.exitSpeedThresholdBps, false);\r\n\r\n          // Only track non-creative/spectator players for phase mode\r\n          if (\r\n            !playersInPhaseMode.has(player.id) &&\r\n            player.getGameMode() !== GameMode.creative &&\r\n            player.getGameMode() !== GameMode.spectator\r\n          ) {\r\n            playersInPhaseMode.set(player.id, initializePlayerTracking(player));\r\n          }\r\n        }\r\n      } catch (playerError) {\r\n        world.sendMessage(`§cError initializing player ${player?.name || \"unknown\"}: ${playerError}`);\r\n      }\r\n    }\r\n\r\n    // Clear any existing intervals to prevent duplicates\r\n    try {\r\n      if (updateIntervalId !== undefined) {\r\n        system.clearRun(updateIntervalId);\r\n        updateIntervalId = undefined;\r\n      }\r\n    } catch (e) {\r\n      // No previous interval exists or error clearing it\r\n      world.sendMessage(`§cWarning: Could not clear previous update interval: ${e}`);\r\n    } // Set up regular update interval for phase mode system\r\n    updateIntervalId = system.runInterval(updatePlayersInPhaseMode, config.speedCheckInterval); // Set up player join handler to enable speedometer for new players\r\n    world.afterEvents.playerJoin.subscribe((event) => {\r\n      try {\r\n        const playerId = event.playerId;\r\n        const player = world.getAllPlayers().find((p) => p.id === playerId);\r\n\r\n        if (player && player.id) {\r\n          // Enable speedometer for new players\r\n          enableSpeedometer(player, config.speedThresholdBps, config.exitSpeedThresholdBps, false);\r\n\r\n          // Track player for phase mode if appropriate\r\n          if (player.getGameMode() !== GameMode.creative && player.getGameMode() !== GameMode.spectator) {\r\n            playersInPhaseMode.set(player.id, initializePlayerTracking(player));\r\n          }\r\n        }\r\n      } catch (e) {\r\n        world.sendMessage(`§cError setting up new player: ${e}`);\r\n      }\r\n    });\r\n\r\n    // Verify the interval was created successfully\r\n    if (updateIntervalId === undefined) {\r\n      world.sendMessage(`§cWARNING: Failed to create update interval`);\r\n    } else {\r\n      world.sendMessage(`§aPhantom Phase system is now monitoring player speeds (interval ID: ${updateIntervalId})`);\r\n    }\r\n\r\n    // Run an immediate check of all players to ensure system is working\r\n    system.runTimeout(updatePlayersInPhaseMode, 1);\r\n\r\n    return true;\r\n  } catch (e) {\r\n    world.sendMessage(`§cFailed to initialize Phantom Phase system: ${e}`);\r\n    return false;\r\n  }\r\n}\r\n","import { world, system, GameMode, Player, Vector3 } from \"@minecraft/server\";\r\n\r\n// Configuration for phantom phase speedometer\r\nconst config = {\r\n  updateInterval: 2, // Update interval in ticks\r\n  barLength: 20, // Length of the visual bar\r\n  phaseColor: \"§b\", // Light blue for phase mode\r\n  warningColor: \"§e\", // Yellow for approaching threshold\r\n  dangerColor: \"§c\", // Red for below exit threshold\r\n  safeColor: \"§a\", // Green for above entry threshold\r\n  actionBarDuration: 10, // How long to show the action bar (ticks)\r\n  speedThresholdBps: 25.0, // Speed threshold to enter phase mode (blocks per second)\r\n  exitSpeedThresholdBps: 7.0, // Speed threshold to exit phase mode (blocks per second)\r\n};\r\n\r\n// Track players with active speedometers\r\nconst activeSpeedometers = new Map<\r\n  string,\r\n  {\r\n    updateIntervalId?: number;\r\n    entryThreshold: number;\r\n    exitThreshold: number;\r\n  }\r\n>();\r\n\r\n/**\r\n * Starts the phase mode speedometer for a player\r\n * @param player The player to enable speedometer for\r\n * @param speedThresholdBps Speed threshold to enter phase mode (blocks per second)\r\n * @param exitSpeedThresholdBps Speed threshold to exit phase mode (blocks per second)\r\n * @param silent Whether to suppress feedback messages\r\n * @returns True if successfully started\r\n */\r\nexport function enableSpeedometer(\r\n  player: Player,\r\n  speedThresholdBps?: number,\r\n  exitSpeedThresholdBps?: number,\r\n  silent: boolean = false\r\n): boolean {\r\n  // Use provided thresholds or defaults from config\r\n  const entryThreshold = speedThresholdBps ?? config.speedThresholdBps;\r\n  const exitThreshold = exitSpeedThresholdBps ?? config.exitSpeedThresholdBps;\r\n\r\n  // Already has active speedometer - update thresholds if different\r\n  if (activeSpeedometers.has(player.id)) {\r\n    const data = activeSpeedometers.get(player.id)!;\r\n    // Update thresholds if they've changed\r\n    if (data.entryThreshold !== entryThreshold || data.exitThreshold !== exitThreshold) {\r\n      data.entryThreshold = entryThreshold;\r\n      data.exitThreshold = exitThreshold;\r\n\r\n      if (!silent) {\r\n        player.sendMessage(\r\n          `§bSpeedometer thresholds updated: Entry ${entryThreshold.toFixed(1)} b/s, Exit ${exitThreshold.toFixed(\r\n            1\r\n          )} b/s`\r\n        );\r\n      }\r\n    } else if (!silent) {\r\n      player.sendMessage(\"§ePhantom Phase speedometer is already active\");\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // Enable speedometer with continuous updates\r\n  const updateIntervalId = system.runInterval(() => {\r\n    updateSpeedometer(player, entryThreshold, exitThreshold);\r\n  }, config.updateInterval);\r\n\r\n  // Store player data with thresholds\r\n  activeSpeedometers.set(player.id, {\r\n    updateIntervalId,\r\n    entryThreshold,\r\n    exitThreshold,\r\n  });\r\n\r\n  if (!silent) {\r\n    player.sendMessage(\"§bPhantom Phase speedometer §aactivated\");\r\n    player.sendMessage(\r\n      `§7Entry threshold: §a${entryThreshold.toFixed(1)} b/s, §7Exit threshold: §e${exitThreshold.toFixed(1)} b/s`\r\n    );\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * Stops the phase mode speedometer for a player\r\n * @param player The player to disable speedometer for\r\n * @param silent Whether to suppress feedback messages\r\n * @returns True if successfully stopped\r\n */\r\nexport function disableSpeedometer(player: Player, silent: boolean = false): boolean {\r\n  if (activeSpeedometers.has(player.id)) {\r\n    const playerData = activeSpeedometers.get(player.id);\r\n    if (playerData?.updateIntervalId) {\r\n      system.clearRun(playerData.updateIntervalId);\r\n    }\r\n\r\n    activeSpeedometers.delete(player.id);\r\n\r\n    if (!silent) {\r\n      player.sendMessage(\"§bPhantom Phase speedometer §cdeactivated\");\r\n    }\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Updates the visual speedometer for a player\r\n * @param player The player to update\r\n * @param entryThreshold Speed threshold to enter phase mode\r\n * @param exitThreshold Speed threshold to exit phase mode\r\n */\r\nfunction updateSpeedometer(player: Player, entryThreshold: number, exitThreshold: number) {\r\n  // Safety check if player disconnected\r\n  if (!player.isValid?.()) {\r\n    if (activeSpeedometers.has(player.id)) {\r\n      disableSpeedometer(player, true);\r\n    }\r\n    return;\r\n  }\r\n\r\n  try {\r\n    // Calculate player speed\r\n    const velocity = player.getVelocity();\r\n    // The scalar 17 is used to convert velocity units to blocks per second\r\n    const speed = 17 * Math.sqrt(velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2);\r\n\r\n    // Determine if in phase mode\r\n    const isInPhaseMode = player.getGameMode() === GameMode.spectator;\r\n\r\n    // Create the visual speedometer bar\r\n    const speedometer = createSpeedometerBar(speed, entryThreshold, exitThreshold, isInPhaseMode);\r\n\r\n    // Display the speedometer in the action bar\r\n    player.onScreenDisplay.setActionBar(speedometer);\r\n  } catch (e) {\r\n    console.warn(\"Failed to update speedometer:\", e);\r\n\r\n    // Even if there's an error, try to show something\r\n    try {\r\n      player.onScreenDisplay.setActionBar(\"§cPhantom Phase speedometer error\");\r\n    } catch {}\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a visual speedometer bar based on current speed and thresholds\r\n */\r\nfunction createSpeedometerBar(\r\n  currentSpeed: number,\r\n  entryThreshold: number,\r\n  exitThreshold: number,\r\n  isInPhaseMode: boolean\r\n): string {\r\n  // Determine the normalized position (0-1) of the speed between min and max\r\n  const position = Math.min(1, Math.max(0, currentSpeed / entryThreshold));\r\n\r\n  // Calculate how many bar segments to fill\r\n  const filledSegments = Math.floor(position * config.barLength);\r\n\r\n  // Determine color based on speed and phase status\r\n  let barColor;\r\n  if (isInPhaseMode) {\r\n    barColor = currentSpeed < exitThreshold ? config.warningColor : config.phaseColor;\r\n  } else {\r\n    barColor =\r\n      currentSpeed >= entryThreshold\r\n        ? config.safeColor\r\n        : currentSpeed >= exitThreshold\r\n        ? config.warningColor\r\n        : config.dangerColor;\r\n  }\r\n\r\n  // Create the progress bar\r\n  let bar = \"§8[\";\r\n\r\n  // Add filled segments with appropriate color\r\n  bar += barColor + \"■\".repeat(filledSegments);\r\n\r\n  // Add empty segments\r\n  bar += \"§8\" + \"□\".repeat(config.barLength - filledSegments);\r\n  bar += \"§8]\";\r\n\r\n  // Create the full speedometer display\r\n  const phaseStatus = isInPhaseMode ? `${config.phaseColor}PHASE` : `§7NORMAL`;\r\n  const speedDisplay = `§f${currentSpeed.toFixed(1)} b/s`;\r\n\r\n  // Add animated indicator if approaching thresholds\r\n  let indicator = \"\";\r\n  if (isInPhaseMode && currentSpeed < exitThreshold + 2) {\r\n    // Blinking warning when close to exiting phase mode\r\n    indicator = system.currentTick % 10 < 5 ? \" §e⚠ EXIT SOON\" : \"\";\r\n  } else if (!isInPhaseMode && currentSpeed > entryThreshold - 5) {\r\n    // Approaching phase entry\r\n    indicator = \" §a↑ PHASE READY\";\r\n  }\r\n\r\n  return `§bPhantom ${phaseStatus}§r ${speedDisplay} ${bar}${indicator}`;\r\n}\r\n\r\n// Automatically clean up speedometers when script is reloaded\r\nsystem.afterEvents.scriptEventReceive.subscribe((event) => {\r\n  if (event.id === \"phantom:cleanup_speedometers\") {\r\n    for (const [playerId, playerData] of activeSpeedometers.entries()) {\r\n      if (playerData.updateIntervalId) {\r\n        system.clearRun(playerData.updateIntervalId);\r\n      }\r\n    }\r\n    activeSpeedometers.clear();\r\n  }\r\n});\r\n"],"mappings":"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","names":["world","system","world","system","GameMode","updateIntervalId","config","GameMode","world","system","world","system"],"file":"../scripts/main.js"}