{"version":3,"sources":["../../scripts/main.ts","../../scripts/phase-mode.ts"],"sourcesContent":["import { world, system } from \"@minecraft/server\";\nimport { initializePhantomPhase, updatePhaseConfig } from \"./phase-mode\";\n\nlet ticksSinceLoad = 0;\n\nfunction mainTick() {\n  ticksSinceLoad++;\n\n  if (ticksSinceLoad === 60) {\n    world.sendMessage(\"§6Phantom Phase system starting minBps: 8...\");\n    initialize();\n  }\n\n  system.run(mainTick);\n}\n\nfunction initialize() {\n  // Initialize the phantom phase system with custom configuration\n  initializePhantomPhase({\n    speedThresholdBps: 25.0, // Enter phase mode at this speed (blocks/second)\n    exitSpeedThresholdBps: 7.0, // Exit phase mode below this speed\n    inactiveFramesThreshold: 20, // Wait this many frames below exit speed before leaving phase mode\n    debugMessages: true, // Show debug messages\n    preserveInventory: true, // Don't lose inventory during mode changes\n  });\n\n  // Example of updating configuration later if needed\n  // system.runTimeout(() => {\n  //   updatePhaseConfig({\n  //     speedThresholdBps: 2.5,  // Lower threshold for easier activation\n  //     debugMessages: false     // Turn off debug messages after initial setup\n  //   });\n  // }, 1200); // 1 minute later (20 ticks/second * 60 seconds)\n}\n\nsystem.run(mainTick);\n","import { world, system, Entity, GameMode, Player, Vector3 } from \"@minecraft/server\";\r\n\r\n// Configuration interface for phantom phase system\r\ninterface PhaseConfig {\r\n  speedThresholdBps: number; // Speed threshold to enter phase mode (blocks per second)\r\n  exitSpeedThresholdBps: number; // Speed threshold to exit phase mode (blocks per second)\r\n  inactiveFramesThreshold: number; // Number of frames below exit speed before exiting phase mode\r\n  ticksPerSecond: number; // Game ticks per second (for calculations)\r\n  speedCheckInterval: number; // How often to check player speeds (in ticks)\r\n  debugUpdateInterval: number; // How often to show debug messages (in ticks)\r\n  debugMessages: boolean; // Whether to show debug messages\r\n  preserveInventory: boolean; // Whether to preserve inventory during mode changes\r\n  gameModeSwitchDelay: number; // Delay in ticks for game mode switches (improves reliability)\r\n  strictValidation: boolean; // Whether to use strict player validation\r\n}\r\n\r\n// Player phase mode data type\r\ninterface PhasePlayerData {\r\n  player: Player;\r\n  lastPosition: Vector3;\r\n  previousSpeed: number;\r\n  inactiveFrames: number;\r\n  previousGameMode?: GameMode;\r\n}\r\n\r\n// Map to track players in phase mode\r\nconst playersInPhaseMode = new Map<string, PhasePlayerData>();\r\n\r\n// Default configuration constants\r\nconst DEFAULT_CONFIG: PhaseConfig = {\r\n  speedThresholdBps: 25.0,\r\n  exitSpeedThresholdBps: 7.0,\r\n  inactiveFramesThreshold: 20,\r\n  ticksPerSecond: 60,\r\n  speedCheckInterval: 1,\r\n  debugUpdateInterval: 10,\r\n  gameModeSwitchDelay: 1,\r\n  strictValidation: true,\r\n  debugMessages: true,\r\n  preserveInventory: true,\r\n};\r\n\r\n// Active configuration\r\nlet config: PhaseConfig = { ...DEFAULT_CONFIG };\r\n\r\n// Store the update interval ID so we can clear it if needed\r\nlet updateIntervalId: number | undefined;\r\n\r\n/**\r\n * Gets player speed directly from the flying_speed component\r\n * Throws an error if the component is not available\r\n */\r\nfunction calculatePlayerSpeed(\r\n  player: Player,\r\n  previousPosition: Vector3,\r\n  intervalTicks: number = config.speedCheckInterval\r\n): number {\r\n  const velocity = player.getVelocity();\r\n  return 17 * Math.sqrt(velocity.x ** 2 + velocity.y ** 2 + velocity.z ** 2);\r\n}\r\n\r\n/**\r\n * Switches player to spectator mode and adds them to phase mode tracking\r\n */\r\nfunction enterPhaseMode(player: Player): void {\r\n  // Prevent redundant mode changes\r\n  if (player.getGameMode() === GameMode.spectator) {\r\n    if (config.debugMessages) {\r\n      world.sendMessage(`§e${player.name} is already in spectator mode, not entering phase mode again.`);\r\n    }\r\n    return;\r\n  }\r\n\r\n  try {\r\n    // Store the previous game mode before changing it\r\n    const previousMode = player.getGameMode();\r\n\r\n    // Add player to phase mode tracking before mode change to prevent race conditions\r\n    playersInPhaseMode.set(player.id, {\r\n      player,\r\n      lastPosition: player.location,\r\n      previousSpeed: 0,\r\n      inactiveFrames: 0,\r\n      previousGameMode: previousMode,\r\n    });\r\n    // Queue the game mode change to happen after a delay for better reliability\r\n    system.runTimeout(() => {\r\n      try {\r\n        // Verify player is still valid and eligible for mode change\r\n        if (player && player.id && !player.isValid?.()) {\r\n          world.sendMessage(`§cPlayer ${player.name} is no longer valid, aborting phase mode entry`);\r\n          playersInPhaseMode.delete(player.id);\r\n          return;\r\n        }\r\n\r\n        // Double check that player hasn't already changed modes\r\n        if (player.getGameMode() !== GameMode.spectator) {\r\n          // Explicitly force spectator mode\r\n          player.setGameMode(GameMode.spectator);\r\n          world.sendMessage(`§b${player.name} is phasing out of reality! (from ${previousMode} mode)`);\r\n        }\r\n      } catch (err) {\r\n        world.sendMessage(`§cERROR: Failed to set spectator mode: ${err}`);\r\n        // Clean up tracking data on failure        playersInPhaseMode.delete(player.id);\r\n      }\r\n    }, config.gameModeSwitchDelay); // Configurable delay for stability\r\n  } catch (e) {\r\n    world.sendMessage(`§cERROR: Failed to set ${player.name} to spectator mode: ${e}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Switches player back to survival mode and removes them from phase tracking\r\n */\r\nfunction exitPhaseMode(player: Player): void {\r\n  try {\r\n    // Get phase data and validate it exists\r\n    const phaseData = playersInPhaseMode.get(player.id);\r\n    if (!phaseData) {\r\n      world.sendMessage(`§cWARNING: No phase data found for ${player.name} when trying to exit phase mode`);\r\n      return;\r\n    }\r\n\r\n    // Use the previous game mode if available, otherwise default to survival\r\n    const targetMode = phaseData.previousGameMode ?? GameMode.survival;\r\n\r\n    // Store a local copy of needed data before removing tracking\r\n    const playerName = player.name;\r\n    const playerId = player.id;\r\n\r\n    // Remove from tracking first to prevent re-entry race conditions\r\n    playersInPhaseMode.delete(playerId);\r\n\r\n    // Schedule the game mode change with a slight delay for better reliability\r\n    system.runTimeout(() => {\r\n      try {\r\n        // Verify player is still valid before proceeding\r\n        if (!player || !player.id || !player.isValid?.()) {\r\n          world.sendMessage(`§cPlayer ${playerName} is no longer valid, aborting phase mode exit`);\r\n          return;\r\n        }\r\n\r\n        // Check current game mode and switch if appropriate\r\n        const currentMode = player.getGameMode();\r\n        if (currentMode === GameMode.spectator) {\r\n          // Explicitly force target mode\r\n          player.setGameMode(targetMode);\r\n          world.sendMessage(`§a${playerName} has returned to reality! (back to ${targetMode} mode)`);\r\n        } else if (currentMode !== targetMode) {\r\n          // They're in an unexpected mode, but not spectator\r\n          world.sendMessage(`§e${playerName} is in ${currentMode} mode, restoring to ${targetMode} mode`);\r\n          player.setGameMode(targetMode);\r\n        } else {\r\n          // They're already in the target mode somehow\r\n          world.sendMessage(`§e${playerName} is already in ${targetMode} mode`);\r\n        }\r\n      } catch (err) {\r\n        world.sendMessage(`§cERROR: Failed to restore game mode for ${playerName}: ${err}`);\r\n      }\r\n    }, config.gameModeSwitchDelay); // Configurable delay for stability\r\n  } catch (e) {\r\n    world.sendMessage(`§cERROR: Failed to restore ${player.name}'s game mode: ${e}`);\r\n    // Still try to clean up the tracking data\r\n    playersInPhaseMode.delete(player.id);\r\n  }\r\n}\r\n\r\n/**\r\n * Displays debug information about a player's current speed and phase status\r\n */\r\nfunction logPlayerDebugInfo(player: Player): void {\r\n  if (!config.debugMessages || system.currentTick % config.debugUpdateInterval !== 0) {\r\n    return;\r\n  }\r\n\r\n  const currentPos = player.location;\r\n  const playerData = playersInPhaseMode.get(player.id);\r\n  const isInPhaseMode = playerData && player.getGameMode() === GameMode.spectator;\r\n  const lastPos = playerData ? playerData.lastPosition : currentPos;\r\n\r\n  try {\r\n    const speed = calculatePlayerSpeed(player, lastPos);\r\n    const speedColor = speed > config.speedThresholdBps ? \"§a\" : speed > config.exitSpeedThresholdBps ? \"§e\" : \"§c\";\r\n\r\n    world.sendMessage(\r\n      `§7${player.name}: speed=${speedColor}${speed.toFixed(2)} §7b/s, isGliding=${\r\n        player.isGliding ? \"§aYes\" : \"§cNo\"\r\n      }, gameMode=${player.getGameMode()}, phaseMode=${isInPhaseMode ? \"§aYES\" : \"§cNO\"}`\r\n    );\r\n  } catch (e: any) {\r\n    // If we can't get speed, just show that the component is not available\r\n    world.sendMessage(\r\n      `§7${player.name}: §cSpeed component not available, isGliding=${\r\n        player.isGliding ? \"§aYes\" : \"§cNo\"\r\n      }, gameMode=${player.getGameMode()}, phaseMode=${isInPhaseMode ? \"§aYES\" : \"§cNO\"}`\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Initializes tracking data for a new player\r\n */\r\nfunction initializePlayerTracking(player: Player): PhasePlayerData {\r\n  return {\r\n    player,\r\n    lastPosition: player.location,\r\n    previousSpeed: 0,\r\n    inactiveFrames: 0,\r\n    previousGameMode: player.getGameMode(),\r\n  };\r\n}\r\n\r\n/**\r\n * Updates phase status for players already in phase mode\r\n */\r\nfunction updateExistingPhasePlayer(player: Player, phaseData: PhasePlayerData): void {\r\n  try {\r\n    const currentSpeed = calculatePlayerSpeed(player, phaseData.lastPosition);\r\n\r\n    phaseData.lastPosition = player.location;\r\n    phaseData.previousSpeed = currentSpeed;\r\n\r\n    if (currentSpeed < config.exitSpeedThresholdBps) {\r\n      phaseData.inactiveFrames++;\r\n\r\n      if (phaseData.inactiveFrames >= config.inactiveFramesThreshold) {\r\n        exitPhaseMode(player);\r\n      }\r\n    } else {\r\n      phaseData.inactiveFrames = 0;\r\n    }\r\n  } catch (e: any) {\r\n    if (config.debugMessages) {\r\n      world.sendMessage(`§c${player.name}: ${e.message}`);\r\n    }\r\n    // If we can't get speed, just keep current state\r\n  }\r\n}\r\n\r\n/**\r\n * Updates and checks players not in phase mode\r\n */\r\nfunction updateRegularPlayer(player: Player): void {\r\n  try {\r\n    let playerData = playersInPhaseMode.get(player.id) || initializePlayerTracking(player);\r\n\r\n    const currentSpeed = calculatePlayerSpeed(player, playerData.lastPosition);\r\n    playerData.lastPosition = player.location;\r\n    playerData.previousSpeed = currentSpeed;\r\n\r\n    if (currentSpeed > config.speedThresholdBps) {\r\n      if (config.debugMessages) {\r\n        world.sendMessage(`§e${player.name} triggered phase mode at ${currentSpeed.toFixed(1)} b/s`);\r\n      }\r\n      enterPhaseMode(player);\r\n    } else if (!playersInPhaseMode.has(player.id)) {\r\n      playersInPhaseMode.set(player.id, playerData);\r\n    }\r\n  } catch (e: any) {\r\n    if (config.debugMessages) {\r\n      world.sendMessage(`§c${player.name}: ${e.message}`);\r\n    }\r\n    // If we can't get speed, don't update player state\r\n  }\r\n}\r\n\r\n/**\r\n * Updates a single player's phase state\r\n */\r\nfunction updatePlayerPhaseState(player: Player): void {\r\n  try {\r\n    // Avoid processing creative/spectator players that aren't already tracked\r\n    const currentGameMode = player.getGameMode();\r\n    const isTracked = playersInPhaseMode.has(player.id);\r\n\r\n    // Don't start tracking spectator players who aren't already tracked\r\n    if (!isTracked && currentGameMode === GameMode.spectator && !isPhaseModeCaused(player)) {\r\n      return;\r\n    }\r\n\r\n    // Get phase data if it exists\r\n    const phaseData = playersInPhaseMode.get(player.id);\r\n\r\n    // If player is in spectator mode and we're tracking them, they're in phase mode\r\n    if (phaseData && currentGameMode === GameMode.spectator) {\r\n      updateExistingPhasePlayer(player, phaseData);\r\n    } else {\r\n      // Otherwise update as a regular player\r\n      updateRegularPlayer(player);\r\n    }\r\n  } catch (e) {\r\n    // Handle any errors that might occur during player state update\r\n    if (config.debugMessages) {\r\n      world.sendMessage(`§cError updating player phase state: ${e}`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if the player is in spectator mode because of our phase system\r\n * rather than manually switching to spectator\r\n */\r\nfunction isPhaseModeCaused(player: Player): boolean {\r\n  const phaseData = playersInPhaseMode.get(player.id);\r\n  return !!phaseData && player.getGameMode() === GameMode.spectator;\r\n}\r\n\r\n/**\r\n * Updates all players' phase status based on speed and conditions\r\n */\r\nfunction updatePlayersInPhaseMode(): void {\r\n  // Clean up players who have left the game first to avoid errors\r\n  cleanupDisconnectedPlayers();\r\n\r\n  const players = world.getAllPlayers();\r\n\r\n  for (const player of players) {\r\n    // Verify player is valid before processing\r\n    try {\r\n      if (player && player.id) {\r\n        logPlayerDebugInfo(player);\r\n        updatePlayerPhaseState(player);\r\n      }\r\n    } catch (err) {\r\n      if (config.debugMessages) {\r\n        world.sendMessage(`§cError updating player: ${err}`);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Clean up any disconnected players from tracking\r\n */\r\nfunction cleanupDisconnectedPlayers(): void {\r\n  // Get the current set of online players for quick lookup\r\n  const onlinePlayers = new Set(world.getAllPlayers().map((p) => p.id));\r\n\r\n  for (const [playerId, data] of playersInPhaseMode.entries()) {\r\n    try {\r\n      let shouldRemove = false;\r\n      let reason = \"unknown\";\r\n\r\n      // Check if player reference is valid\r\n      if (!data.player || !data.player.id) {\r\n        shouldRemove = true;\r\n        reason = \"invalid reference\";\r\n      }\r\n      // Check if player is still connected using the Set for faster lookup\r\n      else if (!onlinePlayers.has(playerId)) {\r\n        shouldRemove = true;\r\n        reason = \"not connected\";\r\n      }\r\n      // Check if player reference is stale or invalid\r\n      else {\r\n        try {\r\n          // Try to access player properties - will throw if reference is invalid\r\n          const _ = data.player.location;\r\n\r\n          // Check isValid method if available\r\n          if (data.player.isValid?.() === false) {\r\n            shouldRemove = true;\r\n            reason = \"reference invalid\";\r\n          }\r\n        } catch (accessError) {\r\n          shouldRemove = true;\r\n          reason = \"reference error\";\r\n        }\r\n      }\r\n\r\n      // Remove player if any check failed\r\n      if (shouldRemove) {\r\n        if (config.debugMessages) {\r\n          const playerName = data.player?.name || \"Unknown\";\r\n          world.sendMessage(`§7Removing player from phase tracking (${reason}): ${playerName}`);\r\n        }\r\n        playersInPhaseMode.delete(playerId);\r\n      }\r\n    } catch (e) {\r\n      // Catch any unexpected errors and remove player from tracking to be safe\r\n      playersInPhaseMode.delete(playerId);\r\n      if (config.debugMessages) {\r\n        world.sendMessage(`§cError during player cleanup: ${e}`);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Update the phantom phase configuration\r\n */\r\nexport function updatePhaseConfig(newConfig: Partial<PhaseConfig>): void {\r\n  config = {\r\n    ...config,\r\n    ...newConfig,\r\n  };\r\n\r\n  if (config.debugMessages) {\r\n    world.sendMessage(`§7Phase mode configuration updated:`);\r\n    world.sendMessage(`§7Speed threshold: §f${config.speedThresholdBps.toFixed(1)} §7blocks/second`);\r\n    world.sendMessage(`§7Exit threshold: §f${config.exitSpeedThresholdBps.toFixed(1)} §7blocks/second`);\r\n  }\r\n}\r\n\r\n/**\r\n * Initializes the phantom phase system that switches fast-moving players to spectator mode\r\n */\r\nexport function initializePhantomPhase(customConfig?: Partial<PhaseConfig>) {\r\n  try {\r\n    // Apply any custom configuration\r\n    if (customConfig) {\r\n      updatePhaseConfig(customConfig);\r\n    }\r\n\r\n    world.sendMessage(\"§2Phantom Phase system activated!\");\r\n    world.sendMessage(`§7Phase speed threshold: §f${config.speedThresholdBps.toFixed(1)} §7blocks/second`);\r\n    world.sendMessage(`§7Exit speed threshold: §f${config.exitSpeedThresholdBps.toFixed(1)} §7blocks/second`);\r\n    world.sendMessage(`§7Mode change delay: §f${config.inactiveFramesThreshold} §7frames`);\r\n\r\n    // Clear any existing players in phase mode\r\n    playersInPhaseMode.clear();\r\n\r\n    // Initialize tracking for all current players\r\n    for (const player of world.getAllPlayers()) {\r\n      try {\r\n        if (\r\n          player &&\r\n          player.id &&\r\n          player.isValid?.() !== false &&\r\n          !playersInPhaseMode.has(player.id) &&\r\n          player.getGameMode() !== GameMode.creative &&\r\n          player.getGameMode() !== GameMode.spectator\r\n        ) {\r\n          playersInPhaseMode.set(player.id, initializePlayerTracking(player));\r\n        }\r\n      } catch (playerError) {\r\n        world.sendMessage(`§cError initializing player ${player?.name || \"unknown\"}: ${playerError}`);\r\n      }\r\n    }\r\n\r\n    // Clear any existing intervals to prevent duplicates\r\n    try {\r\n      if (updateIntervalId !== undefined) {\r\n        system.clearRun(updateIntervalId);\r\n        updateIntervalId = undefined;\r\n      }\r\n    } catch (e) {\r\n      // No previous interval exists or error clearing it\r\n      world.sendMessage(`§cWarning: Could not clear previous update interval: ${e}`);\r\n    }\r\n\r\n    // Set up regular update interval for phase mode system\r\n    updateIntervalId = system.runInterval(updatePlayersInPhaseMode, config.speedCheckInterval);\r\n\r\n    // Verify the interval was created successfully\r\n    if (updateIntervalId === undefined) {\r\n      world.sendMessage(`§cWARNING: Failed to create update interval`);\r\n    } else {\r\n      world.sendMessage(`§aPhantom Phase system is now monitoring player speeds (interval ID: ${updateIntervalId})`);\r\n    }\r\n\r\n    // Run an immediate check of all players to ensure system is working\r\n    system.runTimeout(updatePlayersInPhaseMode, 1);\r\n\r\n    return true;\r\n  } catch (e) {\r\n    world.sendMessage(`§cFailed to initialize Phantom Phase system: ${e}`);\r\n    return false;\r\n  }\r\n}\r\n"],"mappings":"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","names":["world","system","world","system"],"file":"../scripts/main.js"}